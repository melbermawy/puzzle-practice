new structure

phase α — the anatomy of a world

goal: see and understand all the parts that make up a logical world.
	•	lesson 1a — the terrain: arrays, objects, maps, grids. what they represent physically and how to “walk” them.
	•	lesson 1b — the laws: loops, conditionals, and state transitions as causal rules.
	•	lesson 1c — the agents: functions as reusable laws or specialized enzymes; scope and parameters as active sites.

→ drills here aren’t “write code.” they’re “describe what happens in this world step by step” — to train visualization.

⸻

phase β — building coherent physics

goal: master control flow patterns that keep worlds consistent.
	•	lesson 2a — temporal logic: sequences, cause/effect, order of operations.
	•	lesson 2b — conditional physics: handling exceptions and edge cases (like real-world conservation laws).
	•	lesson 2c — simulation patterns: loops as timelines; when to mutate vs. copy.

→ drills: short simulations like “water fills cells in a grid,” “currency exchange through steps,” “disease spreads until no hosts remain.” you narrate before coding.

⸻

phase γ — designing good agents

goal: learn to craft functions that are well-scoped, purposeful, and composable.
	•	lesson 3a — single-responsibility functions (enzymes): each catalyzes one reaction.
	•	lesson 3b — composition: chaining functions as metabolic pathways.
	•	lesson 3c — state isolation: pure vs impure functions; how side effects are like chemical leakage.

→ drills: design tiny “enzymatic” functions, combine them into a pipeline that transforms data clearly.

⸻

phase δ — emergent systems

goal: synthesize everything — small deterministic rules creating coherent worlds.
	•	lesson 4a — finite-state machines (toy physics engines): vending machine, traffic light, predator–prey.
	•	lesson 4b — abstraction & interface: when to expose laws as APIs.
	•	lesson 4c — debugging as observation: tracing cause/effect in your world, like microscopy.

→ drill: progressively build the vending machine; narrate the state evolution at each step before implementing.
